{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dotmgr A dotfile deployment framework Contents New users, see Getting Started Once acclimated, see Guide . This page is also a reference For tips, see Tips For project history, see History","title":"dotmgr"},{"location":"#dotmgr","text":"A dotfile deployment framework","title":"dotmgr"},{"location":"#contents","text":"New users, see Getting Started Once acclimated, see Guide . This page is also a reference For tips, see Tips For project history, see History","title":"Contents"},{"location":"getting-started/","text":"Getting Started Prerequisites Familiarity with Bash scripting Familiarity with Git Pre-existing usage of a dotfile synchronizer The last one is very important . dotmgr is mostly a script manager and you need to already have a way to synchronize dotfiles, like Chezmoi , dotdrop , or rcm . Installation There are two contexts in which dotmgr can be installed: When bootstrapping your dotfiles Initial installation (you're doing this right now) We recommend installing them to the same location. I'll use ~/.dotmgr since it's simple and the initialization scripts in the next step use it by default. You can always change it later git clone 'https://github.com/hyperupcall/dotmgr' ~/.dotmgr You're going to have to add ~/.dotmgr/src/bin to the path manually, in ~/.bashrc or whatever. Just make sure that the file is already managed by a dotfile synchronizer like Chezmoi or your personal tool of choice I personally symlink the dotmgr executable to a common bin directory and add that to the PATH . Since profile.sh is handled (it creates a symlink from ~/.profile ) by my personal dotfile synchronizer, dotfox , everything just works Initialization You're almost ready to rock and roll! We provide an initialization script to automatically generate the directories that dotmgr requires: https://raw.githubusercontent.com/hyperupcall/dotmgr/main/scripts/init.sh | bash Simply follow the insturctions. Once ran, you're ready for Guide","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Familiarity with Bash scripting Familiarity with Git Pre-existing usage of a dotfile synchronizer The last one is very important . dotmgr is mostly a script manager and you need to already have a way to synchronize dotfiles, like Chezmoi , dotdrop , or rcm .","title":"Prerequisites"},{"location":"getting-started/#installation","text":"There are two contexts in which dotmgr can be installed: When bootstrapping your dotfiles Initial installation (you're doing this right now) We recommend installing them to the same location. I'll use ~/.dotmgr since it's simple and the initialization scripts in the next step use it by default. You can always change it later git clone 'https://github.com/hyperupcall/dotmgr' ~/.dotmgr You're going to have to add ~/.dotmgr/src/bin to the path manually, in ~/.bashrc or whatever. Just make sure that the file is already managed by a dotfile synchronizer like Chezmoi or your personal tool of choice I personally symlink the dotmgr executable to a common bin directory and add that to the PATH . Since profile.sh is handled (it creates a symlink from ~/.profile ) by my personal dotfile synchronizer, dotfox , everything just works","title":"Installation"},{"location":"getting-started/#initialization","text":"You're almost ready to rock and roll! We provide an initialization script to automatically generate the directories that dotmgr requires: https://raw.githubusercontent.com/hyperupcall/dotmgr/main/scripts/init.sh | bash Simply follow the insturctions. Once ran, you're ready for Guide","title":"Initialization"},{"location":"guide/","text":"Guide Summary You can customize the behavior of dotmgr in three ways Actions Hooks Profiles For each of those three ways, you can use other files or functions Extras Util TODO: mention core.* TODO: DOTMGR_DIR Actions Actions are at the core of your dotfile management. They are essentially shell scripts, but dotmgr parses their documentation and ordering to create a TUI interface to select a particular script super easily Hooks Hooks are placed in the hooks subdirectory. The supported hooks are: actionPlumbingBefore.sh actionPlumbingAfter.sh actionBefore.sh actionAfter.sh bootstrapBefore.sh bootstrapAfter.sh doctorBefore.sh doctorAfter.sh updateBefore.sh updateAfter.sh The body of the hook must be within the main() function. dotmgr will source your utility files before calling main() . Example: # shellcheck shell=bash main() { printf '%s\\n' 'Hook called!' } Profiles Profiles are used to detect and categorize the currently running system. For example, you might have \"server\", \"desktop\", and \"laptop\" profiles so you can easily deploy different dotfiles Extras Create auxillary files under the extras subdirectory. For example, particular Perl script, or a JSON configuration file may live here Utilities Create utility and helper functions under the util subdirectory. Simply place your functions within a file with a .sh file ending. For example, the following can be put in a util/dot.sh file: # shellcheck shell=bash dot.install_cmd() { local cmd=\"$1\" local pkg=\"$2\" if iscmd \"$cmd\"; then log \"Already installed $cmd\" else log \"Installing $cmd\" if iscmd 'pacman'; then run sudo pacman -S --noconfirm \"$pkg\" elif iscmd 'apt-get'; then run sudo apt-get -y install \"$pkg\" elif iscmd 'dnf'; then run sudo dnf -y install \"$pkg\" elif iscmd 'zypper'; then run sudo zypper -y install \"$pkg\" elif iscmd 'eopkg'; then run sudo eopkg -y install \"$pkg\" elif iscmd 'brew'; then run brew install \"$pkg\" fi if ! iscmd \"$cmd\"; then die \"Automatic installation of $cmd failed\" fi fi } Now, your function is callable by any of your hooks, actions, or profiles like so: dot.install_cmd 'nvim' 'neovim'","title":"Guide"},{"location":"guide/#guide","text":"","title":"Guide"},{"location":"guide/#summary","text":"You can customize the behavior of dotmgr in three ways Actions Hooks Profiles For each of those three ways, you can use other files or functions Extras Util TODO: mention core.* TODO: DOTMGR_DIR","title":"Summary"},{"location":"guide/#actions","text":"Actions are at the core of your dotfile management. They are essentially shell scripts, but dotmgr parses their documentation and ordering to create a TUI interface to select a particular script super easily","title":"Actions"},{"location":"guide/#hooks","text":"Hooks are placed in the hooks subdirectory. The supported hooks are: actionPlumbingBefore.sh actionPlumbingAfter.sh actionBefore.sh actionAfter.sh bootstrapBefore.sh bootstrapAfter.sh doctorBefore.sh doctorAfter.sh updateBefore.sh updateAfter.sh The body of the hook must be within the main() function. dotmgr will source your utility files before calling main() . Example: # shellcheck shell=bash main() { printf '%s\\n' 'Hook called!' }","title":"Hooks"},{"location":"guide/#profiles","text":"Profiles are used to detect and categorize the currently running system. For example, you might have \"server\", \"desktop\", and \"laptop\" profiles so you can easily deploy different dotfiles","title":"Profiles"},{"location":"guide/#extras","text":"Create auxillary files under the extras subdirectory. For example, particular Perl script, or a JSON configuration file may live here","title":"Extras"},{"location":"guide/#utilities","text":"Create utility and helper functions under the util subdirectory. Simply place your functions within a file with a .sh file ending. For example, the following can be put in a util/dot.sh file: # shellcheck shell=bash dot.install_cmd() { local cmd=\"$1\" local pkg=\"$2\" if iscmd \"$cmd\"; then log \"Already installed $cmd\" else log \"Installing $cmd\" if iscmd 'pacman'; then run sudo pacman -S --noconfirm \"$pkg\" elif iscmd 'apt-get'; then run sudo apt-get -y install \"$pkg\" elif iscmd 'dnf'; then run sudo dnf -y install \"$pkg\" elif iscmd 'zypper'; then run sudo zypper -y install \"$pkg\" elif iscmd 'eopkg'; then run sudo eopkg -y install \"$pkg\" elif iscmd 'brew'; then run brew install \"$pkg\" fi if ! iscmd \"$cmd\"; then die \"Automatic installation of $cmd failed\" fi fi } Now, your function is callable by any of your hooks, actions, or profiles like so: dot.install_cmd 'nvim' 'neovim'","title":"Utilities"},{"location":"history/","text":"History My original dotfile manager lived at hyperupcall/dots-bootstrap , but I moved it into hyperupcall/dots to make maintenance easier Sometime thereafter, I moved tools related to dotfile management (specifically hyperupcall/dotshellextract and dotshellgen ) to hyperupcall/dots For many many months, this proved to be a fantastic setup, especially since I was actively developing the \"management\" aspect of my dotfiles (along with the \"configuration\" aspect of course) But, once again, I wanted to separate the \"management\" and \"configuration\" aspect of dotmgr . Since dotmgr was relatively stable, this would benefit hyperupcall/dots by making things more declarative. Additionally, it would make it easier for others to use dotmgr , if they wished to experiment with, or use it Henceforth, hyperupcall/dotmgr was created. I used git-filter-repo to extract the previous ./bootstrap/dotmgr directory to its own repository","title":"History"},{"location":"history/#history","text":"My original dotfile manager lived at hyperupcall/dots-bootstrap , but I moved it into hyperupcall/dots to make maintenance easier Sometime thereafter, I moved tools related to dotfile management (specifically hyperupcall/dotshellextract and dotshellgen ) to hyperupcall/dots For many many months, this proved to be a fantastic setup, especially since I was actively developing the \"management\" aspect of my dotfiles (along with the \"configuration\" aspect of course) But, once again, I wanted to separate the \"management\" and \"configuration\" aspect of dotmgr . Since dotmgr was relatively stable, this would benefit hyperupcall/dots by making things more declarative. Additionally, it would make it easier for others to use dotmgr , if they wished to experiment with, or use it Henceforth, hyperupcall/dotmgr was created. I used git-filter-repo to extract the previous ./bootstrap/dotmgr directory to its own repository","title":"History"},{"location":"tips/","text":"Tips Writing Scripts Do not create functions starting with _ These are reserved by use by dotmgr itself (your scripts are source 'd and name conflicts must be prevented) Troubleshooting Failed to find your dotmgr directory This means dotmgr was not able to deduce your dotmgr content directory . This is the directory that holds your actions, hooks, profiles, and other scripts. By default, it will try to use ~/.dotfiles/dotmgr and ~/.dots/dotmgr . If neither exist, it will error. Avoid the error by writing a .dotmgr_dir file with the content being the full path to your dotmgr content directory. For example, if you cloned this repository to ~/.dotmgr and your dotmgr content directory is at ~/my-dotfiles/dotmgr , then write the file ~/.dotmgr/dotmgr_dir with the content ~/my-dotfiles/dotmgr","title":"Tips"},{"location":"tips/#tips","text":"","title":"Tips"},{"location":"tips/#writing-scripts","text":"Do not create functions starting with _ These are reserved by use by dotmgr itself (your scripts are source 'd and name conflicts must be prevented)","title":"Writing Scripts"},{"location":"tips/#troubleshooting","text":"Failed to find your dotmgr directory This means dotmgr was not able to deduce your dotmgr content directory . This is the directory that holds your actions, hooks, profiles, and other scripts. By default, it will try to use ~/.dotfiles/dotmgr and ~/.dots/dotmgr . If neither exist, it will error. Avoid the error by writing a .dotmgr_dir file with the content being the full path to your dotmgr content directory. For example, if you cloned this repository to ~/.dotmgr and your dotmgr content directory is at ~/my-dotfiles/dotmgr , then write the file ~/.dotmgr/dotmgr_dir with the content ~/my-dotfiles/dotmgr","title":"Troubleshooting"}]}