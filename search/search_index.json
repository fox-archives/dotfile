{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dotmgr A simple dotfile framework STATUS: BETA Pages For creating a dotfiles repository with dotmgr or integrating dotmgr into your own dotfile repository, see Getting Started To see a short guide and reference of how to fully use dotmgr , see Guide For troubleshooting, see Troubleshooting To see the history of this project, see History","title":"`dotmgr`"},{"location":"#dotmgr","text":"A simple dotfile framework STATUS: BETA","title":"dotmgr"},{"location":"#pages","text":"For creating a dotfiles repository with dotmgr or integrating dotmgr into your own dotfile repository, see Getting Started To see a short guide and reference of how to fully use dotmgr , see Guide For troubleshooting, see Troubleshooting To see the history of this project, see History","title":"Pages"},{"location":"getting-started/","text":"Getting Started NOTE : DO NOT USE YET Prerequisites Decent familiarity with Bash scripting Familiarity with Git Initialization There is an initialization script to automatically generate the directories that dotmgr uses https://raw.githubusercontent.com/hyperupcall/dotmgr/main/scripts/init.sh | bash Do not create functions that start with _ . These are reserved by use by dotmgr itself","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"NOTE : DO NOT USE YET","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Decent familiarity with Bash scripting Familiarity with Git","title":"Prerequisites"},{"location":"getting-started/#initialization","text":"There is an initialization script to automatically generate the directories that dotmgr uses https://raw.githubusercontent.com/hyperupcall/dotmgr/main/scripts/init.sh | bash Do not create functions that start with _ . These are reserved by use by dotmgr itself","title":"Initialization"},{"location":"guide/","text":"Guide Summary You can customize the behavior of dotmgr in three ways Actions Hooks Profiles For each of those three ways, you can use other files or functions Extras Util TODO: mention core.* Actions Actions are at the core of your dotfile management. They are essentially shell scripts, but dotmgr parses their documentation and ordering to create a TUI interface to select a particular script super easily Hooks Hooks are placed in the hooks subdirectory. The supported hooks are: actionPlumbingBefore.sh actionPlumbingAfter.sh actionBefore.sh actionAfter.sh bootstrapBefore.sh bootstrapAfter.sh doctorBefore.sh doctorAfter.sh updateBefore.sh updateAfter.sh The body of the hook must be within the main() function. dotmgr will source your utility files before calling main() . Example: # shellcheck shell=bash main() { printf '%s\\n' 'Hook called!' } Profiles Profiles are used to detect and categorize the currently running system. For example, you might have \"server\", \"desktop\", and \"laptop\" profiles so you can easily deploy different dotfiles Extras Create auxillary files under the extras subdirectory. For example, particular Perl script, or a JSON configuration file may live here Utilities Create utility and helper functions under the util subdirectory. Simply place your functions within a file with a .sh file ending. For example, the following can be put in a util/dot.sh file: # shellcheck shell=bash dot.install_cmd() { local cmd=\"$1\" local pkg=\"$2\" if iscmd \"$cmd\"; then log \"Already installed $cmd\" else log \"Installing $cmd\" if iscmd 'pacman'; then run sudo pacman -S --noconfirm \"$pkg\" elif iscmd 'apt-get'; then run sudo apt-get -y install \"$pkg\" elif iscmd 'dnf'; then run sudo dnf -y install \"$pkg\" elif iscmd 'zypper'; then run sudo zypper -y install \"$pkg\" elif iscmd 'eopkg'; then run sudo eopkg -y install \"$pkg\" elif iscmd 'brew'; then run brew install \"$pkg\" fi if ! iscmd \"$cmd\"; then die \"Automatic installation of $cmd failed\" fi fi } Now, your function is callable by any of your hooks, actions, or profiles like so: dot.install_cmd 'nvim' 'neovim'","title":"Guide"},{"location":"guide/#guide","text":"","title":"Guide"},{"location":"guide/#summary","text":"You can customize the behavior of dotmgr in three ways Actions Hooks Profiles For each of those three ways, you can use other files or functions Extras Util TODO: mention core.*","title":"Summary"},{"location":"guide/#actions","text":"Actions are at the core of your dotfile management. They are essentially shell scripts, but dotmgr parses their documentation and ordering to create a TUI interface to select a particular script super easily","title":"Actions"},{"location":"guide/#hooks","text":"Hooks are placed in the hooks subdirectory. The supported hooks are: actionPlumbingBefore.sh actionPlumbingAfter.sh actionBefore.sh actionAfter.sh bootstrapBefore.sh bootstrapAfter.sh doctorBefore.sh doctorAfter.sh updateBefore.sh updateAfter.sh The body of the hook must be within the main() function. dotmgr will source your utility files before calling main() . Example: # shellcheck shell=bash main() { printf '%s\\n' 'Hook called!' }","title":"Hooks"},{"location":"guide/#profiles","text":"Profiles are used to detect and categorize the currently running system. For example, you might have \"server\", \"desktop\", and \"laptop\" profiles so you can easily deploy different dotfiles","title":"Profiles"},{"location":"guide/#extras","text":"Create auxillary files under the extras subdirectory. For example, particular Perl script, or a JSON configuration file may live here","title":"Extras"},{"location":"guide/#utilities","text":"Create utility and helper functions under the util subdirectory. Simply place your functions within a file with a .sh file ending. For example, the following can be put in a util/dot.sh file: # shellcheck shell=bash dot.install_cmd() { local cmd=\"$1\" local pkg=\"$2\" if iscmd \"$cmd\"; then log \"Already installed $cmd\" else log \"Installing $cmd\" if iscmd 'pacman'; then run sudo pacman -S --noconfirm \"$pkg\" elif iscmd 'apt-get'; then run sudo apt-get -y install \"$pkg\" elif iscmd 'dnf'; then run sudo dnf -y install \"$pkg\" elif iscmd 'zypper'; then run sudo zypper -y install \"$pkg\" elif iscmd 'eopkg'; then run sudo eopkg -y install \"$pkg\" elif iscmd 'brew'; then run brew install \"$pkg\" fi if ! iscmd \"$cmd\"; then die \"Automatic installation of $cmd failed\" fi fi } Now, your function is callable by any of your hooks, actions, or profiles like so: dot.install_cmd 'nvim' 'neovim'","title":"Utilities"},{"location":"history/","text":"History My original dotfile manager was at hyperupcall/dots-bootstrap , but I moved it into hyperupcall/dots to make maintenance easier Sometime thereafter, I moved tools related to dotfile management (specifically hyperupcall/dotshellextract and dotshellgen ) to hyperupcall/dots For many many months, this proved to be a fantastic setup, especially since I was actively developing the \"management\" aspect of my dotfiles (along with the \"configuration\" aspect of course) But, once again, I wanted to separate the \"management\" and \"configuration\" aspect of dotmgr . Since dotmgr was relatively stable, this would benefit hyperupcall/dots by making things more declarative. Additionally, it would make it easier for others to use dotmgr , if they wished to experiment with, or use it Henceforth, hyperupcall/dotmgr was created. I used git-filter-repo to extract the previous ./bootstrap/dotmgr directory to its own repository","title":"History"},{"location":"history/#history","text":"My original dotfile manager was at hyperupcall/dots-bootstrap , but I moved it into hyperupcall/dots to make maintenance easier Sometime thereafter, I moved tools related to dotfile management (specifically hyperupcall/dotshellextract and dotshellgen ) to hyperupcall/dots For many many months, this proved to be a fantastic setup, especially since I was actively developing the \"management\" aspect of my dotfiles (along with the \"configuration\" aspect of course) But, once again, I wanted to separate the \"management\" and \"configuration\" aspect of dotmgr . Since dotmgr was relatively stable, this would benefit hyperupcall/dots by making things more declarative. Additionally, it would make it easier for others to use dotmgr , if they wished to experiment with, or use it Henceforth, hyperupcall/dotmgr was created. I used git-filter-repo to extract the previous ./bootstrap/dotmgr directory to its own repository","title":"History"},{"location":"troubleshooting/","text":"Troubleshooting Failed to find your dotmgr directory","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#failed-to-find-your-dotmgr-directory","text":"","title":"Failed to find your dotmgr directory"}]}